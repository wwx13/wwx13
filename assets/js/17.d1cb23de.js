(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{376:function(t,e,s){"use strict";s.r(e);var r=s(44),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"并查集"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[t._v("#")]),t._v(" 并查集")]),t._v(" "),s("p",[t._v("1.用于查询给定的元素所在哪个集合 (一般小于0(n))")]),t._v(" "),s("p",[t._v("2.维护集合的合并")]),t._v(" "),s("p",[t._v("存储需要O（n）空间。存储的空间用于存储对应索引的元素的父节点的索引。这里的集合可以理解为，代表元素是根节点，其余集合元素都是非根节点。")]),t._v(" "),s("p",[t._v("如果我们有需要查询某个元素在个集合中，或者需要通过合并集合完成任务，可以优先考虑这个数据结构。")]),t._v(" "),s("h2",{attrs:{id:"并查集的思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并查集的思想"}},[t._v("#")]),t._v(" 并查集的思想")]),t._v(" "),s("p",[t._v("构建：\n给到一个原始列表，用等长的列表存储每个原列表元素对应的父节点索引（集合根节点索引）。\n如果给定的结果中没有任何元素归属，可以认为元素自己就是一个集合。")]),t._v(" "),s("p",[t._v("查询：\n给定一个索引，查询所属集合就是查询根节点。只需要递归的查询当前节点的父节点的根节点。根节点的特点就是当前节点索引和父节点索引相同。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("优化技巧：由于并查集查询很依赖结构，我们会在每次查询时，努力把深度大于2的节点，直接连接根节点，变成深度为2。这称为路径压缩。")])]),t._v(" "),s("p",[t._v("合并集合：给定两个索引，需要合并这两个索引所在集合。那么只需要找到各自根节点，使得其中任何一个指向另一个作为子节点就行。")]),t._v(" "),s("p",[t._v("练手题目：\n"),s("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-provinces/",target:"_blank",rel:"noopener noreferrer"}},[t._v("省份数目"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);