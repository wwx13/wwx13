(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{675:function(t,a,s){"use strict";s.r(a);var i=s(44),l=Object(i.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"prim算法与dijikstra算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prim算法与dijikstra算法"}},[t._v("#")]),t._v(" Prim算法与Dijikstra算法")]),t._v(" "),s("p",[t._v("为什么要写这两个算法呢，这两个算法prim处理最小生成树，dijikstra处理单源最短路径，\n但是在算法组成上有些相似，对比一下学习的好。")]),t._v(" "),s("ol",[s("li",[t._v("Prim")])]),t._v(" "),s("ul",[s("li",[t._v("Prim算法能让我们在有向/无向图中建立最小的生成树。也就是找到n-1个边链接n个不同节点。\n核心思想是维护两个集合， 第一个集合表示已经连接入树的节点， 一个集合表示未连接入树的节点。\n"),s("ul",[s("li",[t._v("我们维护一个数组表示所有节点到已入树节点集合的最近距离。（L1）")]),t._v(" "),s("li",[t._v("维护一个数组，表示所有节点到已入树节点中最近的那个节点是谁。初始，第一个节点为-1，表示\n是起始节点（根节点）。（L2）")]),t._v(" "),s("li",[t._v("每次选择距离最近的、且未访问的节点入树\n对该节点直接连接的的节点的最近距离松弛： 如果该节点到连接节点距离 小于当前连接节点\n保存在数组的最近距离，则更新为小的值。")]),t._v(" "),s("li",[t._v("直到所有节点都入了树。")])])]),t._v(" "),s("li",[t._v("复杂度：我们需要移动V个点入树，每次需要在V个点距离中找最近的未入树的点。我们一共松弛\nE次。 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("（")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("V")]),s("msup",[s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mn",[t._v("2")])],1),s("mi",{attrs:{mathvariant:"normal"}},[t._v("）")]),s("mo",[t._v("+")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("E")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O（|V|^2） + |E|")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1.064108em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mord cjk_fallback"},[t._v("（")]),s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.22222em"}},[t._v("V")]),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[s("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])]),s("span",{staticClass:"mord cjk_fallback"},[t._v("）")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),s("span",{staticClass:"mbin"},[t._v("+")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05764em"}},[t._v("E")]),s("span",{staticClass:"mord"},[t._v("∣")])])])]),t._v("。")]),t._v(" "),s("li",[t._v("堆优化\n"),s("ul",[s("li",[t._v("堆优化的是在松弛过的V个点中找最近，我们用最小堆替代L1，但是这里堆存的不止V个点，\n实际上最后会迭代不断增加至|E|个，初始可以只存与第一个节点有链接的x个边和节点。因此，\n可以认为查询最近点优化到"),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mi",[t._v("l")]),s("mi",[t._v("o")]),s("msub",[s("mi",[t._v("g")]),s("mrow",[s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("E")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")])],1)],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("log_{|E|}")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1.04964em","vertical-align":"-0.3551999999999999em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.01968em"}},[t._v("l")]),s("span",{staticClass:"mord mathdefault"},[t._v("o")]),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03588em"}},[t._v("g")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t vlist-t2"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.34480000000000005em"}},[s("span",{staticStyle:{top:"-2.5198em","margin-left":"-0.03588em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[s("span",{staticClass:"mord mtight"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault mtight",staticStyle:{"margin-right":"0.05764em"}},[t._v("E")]),s("span",{staticClass:"mord mtight"},[t._v("∣")])])])])]),s("span",{staticClass:"vlist-s"},[t._v("​")])]),s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.3551999999999999em"}},[s("span")])])])])])])])]),t._v("。 "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("（")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("V")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("l")]),s("mi",[t._v("o")]),s("msub",[s("mi",[t._v("g")]),s("mrow",[s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("E")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")])],1)],1),s("mi",{attrs:{mathvariant:"normal"}},[t._v("）")]),s("mo",[t._v("+")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")]),s("mi",[t._v("E")]),s("mi",{attrs:{mathvariant:"normal"}},[t._v("∣")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O（|V|log_{|E|}） + |E|")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1.1052em","vertical-align":"-0.3551999999999999em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mord cjk_fallback"},[t._v("（")]),s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.22222em"}},[t._v("V")]),s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.01968em"}},[t._v("l")]),s("span",{staticClass:"mord mathdefault"},[t._v("o")]),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03588em"}},[t._v("g")]),s("span",{staticClass:"msupsub"},[s("span",{staticClass:"vlist-t vlist-t2"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.34480000000000005em"}},[s("span",{staticStyle:{top:"-2.5198em","margin-left":"-0.03588em","margin-right":"0.05em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),s("span",{staticClass:"sizing reset-size6 size3 mtight"},[s("span",{staticClass:"mord mtight"},[s("span",{staticClass:"mord mtight"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault mtight",staticStyle:{"margin-right":"0.05764em"}},[t._v("E")]),s("span",{staticClass:"mord mtight"},[t._v("∣")])])])])]),s("span",{staticClass:"vlist-s"},[t._v("​")])]),s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.3551999999999999em"}},[s("span")])])])])]),s("span",{staticClass:"mord cjk_fallback"},[t._v("）")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),s("span",{staticClass:"mbin"},[t._v("+")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord"},[t._v("∣")]),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05764em"}},[t._v("E")]),s("span",{staticClass:"mord"},[t._v("∣")])])])]),t._v("。")])])]),t._v(" "),s("li",[t._v("最小生成树的获得\n"),s("ul",[s("li",[t._v("如果需要构建出树，那么可以从最终的L2数组构建，首先找到根节点，然后找到与它相连\n的节点（L2需要构建成字典，翻转键值）。理论上是O（|V|）复杂度。注意，L2等于是一个\n节点声明父节点是谁，我们知道树的节点父节点唯一，因此翻转键值就是一个节点的子节点有\n谁，这个可以有多个。")])])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("Dijikstra")])]),t._v(" "),s("ul",[s("li",[t._v("Dijikstra算法是在有/无向图找到单起点的最短路径。\n"),s("ul",[s("li",[t._v("我们先聊聊单源最短路径问题的一个非常重要的性质：最优子结构性质。\n我们可以问问自己， 如果源点到达S点的最优路径中包括M点，那么源点到M点的路径也是最优的吗？\n答案是是的， 路径中的任意一点到源点的路径都是最优的。"),s("br"),t._v("\n记住，松弛的具体操作就是来源于这个思想。")]),t._v(" "),s("li",[t._v("算法的具体内容\n"),s("ul",[s("li",[t._v("核心思想：维护两个集合， 一个表示源点已经找到最优路径到达的节点，一个是源点未到达\n并得到最优路径的节点。")]),t._v(" "),s("li",[t._v("我们维护一个数组表示所有节点到源点的最近距离。（L1）")]),t._v(" "),s("li",[t._v("维护一个数组，表示所有节点最短路径上连接的前一个节点，也就是松弛节点。初始，第一个节点为-1，表示\n是起始节点。其余节点初始化为源点。（L2）")]),t._v(" "),s("li",[t._v("每次选择距离源点最近的，且未已找到最短路径的节点。\n对该节点其相连的所有其他的节点的距离 加上当前节点距离源点的值 与 其他节点距离源点的")]),t._v(" "),s("li",[t._v("值比较，如果更小则更新对应节点的L1, L2数组。")]),t._v(" "),s("li",[t._v("直到所有节点都已找到最短路径。")])])]),t._v(" "),s("li",[s("h2",{attrs:{id:"复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[t._v("#")]),t._v(" 复杂度")])])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);