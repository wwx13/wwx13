(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{650:function(t,v,a){"use strict";a.r(v);var _=a(44),r=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"kd树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kd树"}},[t._v("#")]),t._v(" KD树")]),t._v(" "),a("ol",[a("li",[t._v("kd树其实是一个二叉搜索树。但是为什么放在机器学习里呢？因为在某些机器学习方法里会\n使用kd树来实现。例如KNN。")])]),t._v(" "),a("h1",{attrs:{id:"knn"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#knn"}},[t._v("#")]),t._v(" KNN")]),t._v(" "),a("h2",{attrs:{id:"思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#思想"}},[t._v("#")]),t._v(" 思想")]),t._v(" "),a("p",[t._v("预测时，输入一个向量在已有的实例向量中找到最近距离的k个，利用某些决策规则如 多数表决策略， 这K个最多的类别\n就赋予输入向量这个类别。训练时，把类心的类别作为这个cell的类别。当K=1，我们称为最近邻。K近邻实际上是对训练集的向量进行特征空间的划分打上类别，并作为分类的模型。")]),t._v(" "),a("h2",{attrs:{id:"三个问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个问题"}},[t._v("#")]),t._v(" 三个问题")]),t._v(" "),a("ol",[a("li",[t._v("K值选择\n"),a("a",{attrs:{href:""}},[t._v("交叉验证法")])]),t._v(" "),a("li",[t._v("距离度量\n"),a("a",{attrs:{href:"./pics/knn.png"}},[t._v("knn")])]),t._v(" "),a("li",[t._v("决策规则\nKD树的建立类似于数据的训练，建立树就建立了模型， KD树的搜索就是预测。搜索的目的是搜索最近的K个节点。")])]),t._v(" "),a("ul",[a("li",[t._v("构建KD树")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[t._v("选取方差最大的特征作为分割特征；")])]),t._v(" "),a("li",[a("p",[t._v("选择该特征的中位数作为分割点；")])]),t._v(" "),a("li",[a("p",[t._v("将数据集中该特征小于中位数的传递给根节点的左儿子，大于中位数的传递给根节点的右儿子；")])]),t._v(" "),a("li",[a("p",[t._v("递归执行步骤2-4，直到所有数据都被建立到KD Tree的节点上为止。")])])]),t._v(" "),a("ul",[a("li",[t._v("搜索KD树")])]),t._v(" "),a("p",[t._v("KD Tree建好之后，接下来就要利用KD Tree对元素进行查找了。查找的方式在BST的基础上又增加了一些难度，如下：")]),t._v(" "),a("p",[t._v("下面示例最近邻的搜索k=1。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("从根节点开始，根据目标在分割特征中是否小于或大于当前节点，向左或向右移动。")])]),t._v(" "),a("li",[a("p",[t._v("一旦算法到达叶节点，它就将节点点保存为“当前最佳”。")])]),t._v(" "),a("li",[a("p",[t._v("回溯，即从叶节点再返回到根节点")])]),t._v(" "),a("li",[a("p",[t._v("如果当前节点比当前最佳节点更接近，那么它就成为当前最好的。")])]),t._v(" "),a("li",[a("p",[t._v("如果目标点距离 当前节点的父节点的分割超平面 小于 目标点距离当前节点（即当前最近距离），说明当前节点的兄弟节点所在的子树有可能包含更近的点。因此需要对这个兄弟节点递归执行1-4步")])])]),t._v(" "),a("h5",{attrs:{id:"说明步骤5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说明步骤5"}},[t._v("#")]),t._v(" 说明步骤5")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("如果目标点距离 当前节点的父节点的分割超平面 小于 目标点距离当前节点，\n等价于分割维度取值向超平面另一侧移动距离变小。\n")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);