(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{562:function(e,n,a){e.exports=a.p+"assets/img/heapfiy.9fd413a8.png"},669:function(e,n,a){"use strict";a.r(n);var l=a(44),i=Object(l.a)({},(function(){var e=this,n=e.$createElement,l=e._self._c||n;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h1",{attrs:{id:"堆"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[e._v("#")]),e._v(" 堆")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("堆的思想")]),e._v(" "),l("ol",[l("li",[e._v("堆是用数组存储的完全二叉树。分为最小堆，最大堆，堆的特点是父节点大于或小于子节点。"),l("br")]),e._v(" "),l("li",[e._v("一个节点的子节点为 2i + 1， 2i+2"),l("br")]),e._v(" "),l("li",[e._v("堆的基本操作有 上浮， 下降， 出头， 尾插入。 均摊复杂度是log(n)。")]),e._v(" "),l("li",[e._v("堆排序是出头的过程，均摊复杂度为nlog(n)。")]),e._v(" "),l("li",[e._v("堆常用于需要不断维护数据有序的场景。")])])]),e._v(" "),l("li",[l("p",[e._v("建立堆\n首先，存储堆大小和输入序列相同，直接作为初始值。然后\n一般是从底开始shift down建立，需要shift的索引是从0到len(输入序列)//2。这个可以由非底层\n叶节点总数计算上取整而来。\nshiftdown好处就是，我们知道叶节点是不需要向下比较的，\n如果我们bubble，实际叶节点也必须移动，会更花时间。\nO（n）. 证明如下:\n"),l("img",{attrs:{src:a(562),alt:"complexity"}})])]),e._v(" "),l("li",[l("p",[e._v("堆出头\n直接pop头，然后把倒数第一个叶节点补充到头，做shiftdown.")])]),e._v(" "),l("li",[l("p",[e._v("尾插入\n直接尾巴插入，然后做bubble。")])])]),e._v(" "),l("h3",{attrs:{id:"棍棍我的代码-你参考看看"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#棍棍我的代码-你参考看看"}},[e._v("#")]),e._v(" 棍棍我的代码，你参考看看")]),e._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[e._v('\n"""\n堆的操作元素使用自定义的Node类型，这样方便实际套用，因为实际使用中，经常需要排序元素和自带的属性一起\n随着数据结构变化。\n"""\n\n\nclass Node(object):\n    def __init__(self, val):\n        # define any other attrs in val.\n        # val = {"name1":, "name2":}\n        self.val = val\n\n\nclass Heap(object):\n    def __init__(self, array, compare_key):\n        # max_heap\n        # [like Node instance]\n        self.array = array\n        self.compare_key = compare_key\n        self.heap = self.build_heap(self.array)\n\n    def bubble(self, idx, heap=None):\n        if heap is None:\n            heap = self.heap\n        while idx > 0:\n            parent = (idx - 1) // 2\n            if heap[parent].val[self.compare_key] < heap[idx].val[self.compare_key]:\n                temp = heap[idx]\n                heap[idx] = heap[parent]\n                heap[parent] = temp\n                idx = parent\n            else:\n                break\n\n    def down(self, idx, heap=None):\n        if heap is None:\n            heap = self.heap\n        while idx < len(heap):\n            child_idx_l = 2 * idx + 1\n            child_idx_r = 2 * idx + 2\n            if child_idx_l < len(heap) and child_idx_r < len(heap):\n                max_val = max(heap[idx].val[self.compare_key],\n                              heap[child_idx_r].val[self.compare_key],\n                              heap[child_idx_l].val[self.compare_key])\n                if max_val == heap[idx].val[self.compare_key]:\n                    break\n                else:\n                    if max_val == heap[child_idx_l].val[self.compare_key]:\n                        swap = heap[child_idx_l]\n                        heap[child_idx_l] = heap[idx]\n                        heap[idx] = swap\n                        idx = child_idx_l\n                    else:\n                        swap = heap[child_idx_r]\n                        heap[child_idx_r] = heap[idx]\n                        heap[idx] = swap\n                        idx = child_idx_r\n            elif child_idx_l < len(heap):\n                max_val = max(heap[idx].val[self.compare_key],\n                              heap[child_idx_l].val[self.compare_key])\n                if max_val == heap[idx].val[self.compare_key]:\n                    break\n                else:\n                    swap = heap[child_idx_l]\n                    heap[child_idx_l] = heap[idx]\n                    heap[idx] = swap\n                    idx = child_idx_l\n            else:\n                break\n\n    def pop_head(self):\n        head = self.heap.pop(0)\n        if self.heap:\n            self.heap.insert(0, self.heap[-1])\n            self.heap.pop(-1)\n            self.down(0)\n        return head\n\n    def insert_tail(self, val):\n        idx = len(self.heap)\n        self.heap.append(val)\n        self.bubble(idx)\n        pass\n\n    def sort(self):\n        max_min_order = []\n        while self.heap:\n            max_min_order.append(self.pop_head())\n        return max_min_order\n\n    def build_heap(self, array):\n        for i in range(len(array)//2, -1, -1):\n            self.down(i, array)\n        return array\n\n')])])]),l("p",[e._v("练手题目："),l("br"),e._v(" "),l("a",{attrs:{href:"https://leetcode-cn.com/problems/car-pooling/",target:"_blank",rel:"noopener noreferrer"}},[e._v("拼车"),l("OutboundLink")],1),l("br"),e._v(" "),l("a",{attrs:{href:"https://leetcode-cn.com/problems/ugly-number-ii/submissions/",target:"_blank",rel:"noopener noreferrer"}},[e._v("丑数"),l("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=i.exports}}]);