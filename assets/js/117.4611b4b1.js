(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{686:function(t,e,r){"use strict";r.r(e);var n=r(44),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("hr"),t._v(" "),r("h2",{attrs:{id:"home-falsetitle-数据结构与算法footer-mit-licensed-copyright-©-vincent-blv"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#home-falsetitle-数据结构与算法footer-mit-licensed-copyright-©-vincent-blv"}},[t._v("#")]),t._v(" home: false\ntitle: 数据结构与算法\nfooter: MIT Licensed | Copyright © vincent blv")]),t._v(" "),r("h1",{attrs:{id:"并查集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并查集"}},[t._v("#")]),t._v(" 并查集")]),t._v(" "),r("p",[t._v("1.用于查询给定的元素所在哪个集合 (一般小于0(n))")]),t._v(" "),r("p",[t._v("2.维护集合的合并")]),t._v(" "),r("p",[t._v("存储需要O（n）空间。存储的空间用于存储对应索引的元素的父节点的索引。这里的集合可以理解为，代表元素是根节点，其余集合元素都是非根节点。")]),t._v(" "),r("p",[t._v("如果我们有需要查询某个元素在个集合中，或者需要通过合并集合完成任务，可以优先考虑这个数据结构。")]),t._v(" "),r("h2",{attrs:{id:"并查集的思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并查集的思想"}},[t._v("#")]),t._v(" 并查集的思想")]),t._v(" "),r("p",[t._v("构建：\n给到一个原始列表，用等长的列表存储每个原列表元素对应的父节点索引（集合根节点索引）。\n如果给定的结果中没有任何元素归属，可以认为元素自己就是一个集合。")]),t._v(" "),r("p",[t._v("查询：\n给定一个索引，查询所属集合就是查询根节点。只需要递归的查询当前节点的父节点的根节点。根节点的特点就是当前节点索引和父节点索引相同。")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),r("p",[t._v("优化技巧：由于并查集查询很依赖结构，我们会在每次查询时，努力把深度大于2的节点，直接连接根节点，变成深度为2。这称为路径压缩。")])]),t._v(" "),r("p",[t._v("合并集合：给定两个索引，需要合并这两个索引所在集合。那么只需要找到各自根节点，使得其中任何一个指向另一个作为子节点就行。")]),t._v(" "),r("p",[t._v("练手题目："),r("br"),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-provinces/",target:"_blank",rel:"noopener noreferrer"}},[t._v("省份数目"),r("OutboundLink")],1),r("br"),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/longest-consecutive-sequence/",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长连续序列"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("题解:\n1.最长连续序列"),r("br")]),t._v(" "),r("ul",[r("li",[t._v("把连续当做集合合并的条件，我们考虑最长的连续序列其实就是拥有做多元素的集合 等价于\n指向相同根节点的元素的最多个数。注意并查集合并完，数组里在一个集合的元素记录的父节点未必是同一个，\n因为更新有时间差，所以需要遍历一下父节点数据，query一遍更新。"),r("br"),t._v("\n2.省份数目"),r("br")]),t._v(" "),r("li",[t._v("标准的并差集题目，一个集合内部元素彼此是联通的，只要依次联通就行，最后查询一下最新的父节点。"),r("br")])])])}),[],!1,null,null,null);e.default=s.exports}}]);