(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{563:function(n,t,l){n.exports=l.p+"assets/img/prefix.245fcc8d.png"},674:function(n,t,l){"use strict";l.r(t);var e=l(44),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前n项的和”。\n二维/多维前缀和¶多维前缀和的普通求解方法几乎都是基于容斥原理。\n例如:\n"),e("img",{attrs:{src:l(563),alt:"二维差分"}}),n._v("\n请着重思考一下最后一句加减。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("例题: 在一个 n*m 的只包含 0 和 1 的矩阵里找出一个不包含 0 的最大正方形，输出边长。")])]),n._v(" "),e("li",[e("p",[n._v("思路： 我们先计算矩阵前缀和。再计算每个长度为固定的(q) 取值范围2到min(H,W)：H 高度，W宽度的方阵是否\n是满足要求的就行。其中每个 x*x的方阵，通过遍历每个长度(l)和高度(m)都大于x的矩阵差分 F[m][l-q], F[m-q][l]")])])]),n._v(" "),e("ul",[e("li",[n._v("F[m-q][l-q]得到 q*q的矩阵。 复杂度 min(H,W)^3")])])])}),[],!1,null,null,null);t.default=s.exports}}]);