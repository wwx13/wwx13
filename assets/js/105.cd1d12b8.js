(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{668:function(n,e,t){"use strict";t.r(e);var _=t(44),i=Object(_.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[t("strong",[n._v("最近回溯")])]),n._v(" "),t("p",[n._v("最近回溯是这样的：\n要求能找到最近的一个分叉点，并从小到大的进行试验，直到试验出一个通路，\n这个思路可以通过指针进行实现，时间复杂度比动态规划可能好一些，取决于问题本身，但是\n空间复杂度肯定很低很多。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('https://leetcode-cn.com/problems/wildcard-matching/submissions/\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n    \n        引理： 如果从左到右匹配过程中，发现当前字符无法和当前正则字符匹配，则只需要调整最近前面的那个*，如果调整不成功则匹配就失败了。\n        证明： 证明主要集中在为什么最近那个通配符而不是靠前的。因为，如果倒数第二个通配符需要匹配更多字符，那么完全也可以由倒数第一个\n        通配符去完成。因为，倒数第二个本来和介于倒数第一个通配符之间的正则可以匹配原串，此时倒数第一个通配符就可以完成匹配之后更多对的字符，\n\n        因此我们调整匹配过程，只需要关注在无法匹配时，能不能调整最近通配符贪婪的字符串个数。从少到多的尝试。\n        \n        matched_s_ix = 0\n        real_matched_s_ix = None\n        temp_p_ix = 0\n        pointer_star_ix = None\n\n        while matched_s_ix < len(s):\n            # print(temp_p_ix)\n            if temp_p_ix < len(p) and p[temp_p_ix] != "*" and (s[matched_s_ix] == p[temp_p_ix] or p[temp_p_ix] == "?"):\n                matched_s_ix += 1\n                temp_p_ix += 1\n            elif  temp_p_ix < len(p) and p[temp_p_ix] == "*":\n                if temp_p_ix == len(p)-1:\n                    return True\n                pointer_star_ix = temp_p_ix\n                temp_p_ix += 1\n                real_matched_s_ix = matched_s_ix\n            else:\n                if pointer_star_ix is None:\n                    return False\n                temp_p_ix = pointer_star_ix + 1\n                matched_s_ix = real_matched_s_ix + 1\n                real_matched_s_ix += 1\n\n            # if temp_p_ix >= len(p) and matched_s_ix <= len(s)-1:\n                # return False\n        last = p[temp_p_ix:]\n        if not last:\n            return True\n        else:\n            return all([i=="*"  for i in last])\n')])])]),t("p",[n._v("练手题目："),t("br"),n._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/wildcard-matching",target:"_blank",rel:"noopener noreferrer"}},[n._v("通配符"),t("OutboundLink")],1),t("br")])])}),[],!1,null,null,null);e.default=i.exports}}]);